#!/usr/bin/env node
const _ = require('lodash');
const minimist = require('minimist');
const {
  Commands,
  getPackages,
  changelogJson,
  rmChangelogJson,
  writeChangelogJsonForPackage
} = require('@pie-framework/build-helper');
const args = minimist(process.argv.slice(2));
const { resolve, join, basename } = require('path');

class LibCommands extends Commands {
  async deploy() {
    const demoDir = resolve(this.projectRoot, 'packages', 'demo');
    const next = this.bin('next');
    await this.runCmds([`${next} build`, `${next} export`], { cwd: demoDir });

    const alias = `pie-lib${args.next ? '-next' : ''}`;
    return this.staticToNow(resolve(demoDir, 'out'), alias);
  }

  /**
   * Override this so that the changelogs dont get removed.
   * We want to pull them in to the demo site build.
   */
  afterPublish() {
    return Promise.resolve(undefined);
  }

  rmChangelogs() {
    return rmChangelogJson(join(this.projectRoot, 'packages'));
  }

  /** called by each package in prepack */
  changelog() {
    const packagesDir = join(this.projectRoot, 'packages');
    const allPackages = getPackages(packagesDir);
    const packages = this.args.scope
      ? allPackages.filter(p => basename(p.dir) === this.args.scope)
      : allPackages;

    return Promise.all(
      packages.map(async pkg => {
        // This function is called from prepack - so we don't know if it's next or not
        const clPath = await writeChangelogJsonForPackage(pkg, false);
        // Next changelog is ignored so skip
        await this.commit(
          [clPath],
          `[travis skip] update changelog.json for ${pkg.pkg.name}`
        );
      })
    );
  }

  async logChangelog() {
    const packages = _.take(getPackages(join(this.projectRoot, 'packages')), 1);

    const changelogs = await Promise.all(
      packages.map(p => changelogJson(p, { type: 'released' }))
    );
    console.log('changelogs', changelogs);
    // const unreleased = await Promise.all(
    //   packages.map(p => changelogJson(p, { type: 'unreleased' }))
    // );
    // console.log('unreleased', unreleased);
  }
}

const cmds = new LibCommands(resolve(__dirname, '..'), args);

cmds
  .execute()
  .then(() => {
    console.log('all done');
    process.exit(0);
  })
  .catch(e => {
    console.error(e);
    process.exit(1);
  });
